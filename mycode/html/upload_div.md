# 盒子模型与样式排版
    学习html，css部分，就是玩拼图，把一些碎片放到正确位置上就可以显示了
## 块元素基础特性(block-level)
    概念: 为了让开发人员可以更好的对网页进行布局,可以把网页分割成一个个区块

    常用块元素:
        div,p,h1-h6,ul,ol,li
    块元素的特性:
        1.块元素总是独占一行,从新的一行
        2.块元素的高度,宽度,行高,内外边距,间距都可以自己来设置
        3.块元素的默认宽度为浏览器端的100%(网页是有默认样式,有内外边距)
        4.块元素里面可以包含行内元素/其他的块元素
    块元素就像是地主,有自己的一块独立地盘
## 行内元素基础特性(inline-level)
    概念:和块元素相比,行内元素就像是打工仔,设有独立地盘,他的大小就是自身内容的大小(文本内容,图片大小),一般不可以设置宽高,对齐属性,主要用于控制网页里的文本样式

    常用行内元素:
        a,strong,span,i,u(最经典的行内标签就是span)
    行内元素的特性:
        1.行内元素的默认高度是按照内容来的
        2.行内元素不能设置宽度和高度的,不具备结构能力,设置了也白搭
        3.行内元素不会独占一行,统一在一行,多个行内元素可以共存
        4.行内元素不能放块元素,行内元素只能存放文本.其他行内元素
    a标签比较特殊,它是和用户体验交互相关的,如果一个a标签很小不好点击,就不方便,所以a标签里面是可以包裹块元素,主要是为了拓展移动端,让相应区域更加大

    img标签:行内元素
        img虽然可以设置宽高,但是本质还是行内元素.宽度和高度都是它自身属性-->多媒体标签

## 行内块元素(inline-block)
    行内块元素是inline和block的结合体,同时具备两者的特性(主块 辅行)
        1.和相邻的行内元素(行内块)在一行时,会有一个空白(每一个标签末尾都有空格)
        2.默认宽度是自身内容宽度
        3.高度,行高,内外边距都可以设置

## 元素类型转换
    display: 类型转换样式
        display: block 把标签转为块元素
        display: inline 把标签转为行内元素

## 盒子模型:
    盒子组成:
        外边距 --> 边框 --> 内边距 --> 内容
    内边距padding:
            盒子里的内容离盒子的距离
    外边距margin:
            盒子离盒子外部的距离

    如果把盒子的宽高写死了的情况下,再设置padding内边距,就会把盒子撑大
    如果盒子没有设定宽高,它就不会随着padding撑大,而是随着内容产生变化

    盒子的核心属性:
        width: 宽度 --> 
        height: 高度 --> 默认为盒子内容
        overflow: 溢出 --> 处理溢出内容
            hidden 隐藏溢出部分
            visible 显示溢出的部分
            scroll 可以通过滚动条,查看溢出部分
            auto 让浏览器自动设置

## 盒模型标签属性:
    复合写法 
        一个标签里面有很多属性,可以给它一次性写完
    background:样式1 样式2 样式3
    background:url('../img/1.jpg') center/cover'
    
    margin --> 设置外边距;
        margin:10px;
    padding --> 设置内边距
        padding:10px;

    border --> 设置边框属性
        border:3px solid #096;
    border-width --> 设置边框宽度/厚度
        border-width: 5px;
    border-color -->设置边框颜色
        border-color: gold;
    border-style --> 设置边框样式
        border-style:none;没有样式
        border-style:solid;单实线(常用)
        border-style:dashed;虚线
        border-style:dotted;点线
        border-style:double;双实线
    border-radius --> 设置边框圆角
        border-radius:15px;
    
    border-right -->设置右边框
    border-left --> 设置左边框
    border-top --> 设置上边框
    border-buttom -->设置下边框

    padding-right:设置右内间距
    padding-left --> 设置左内间距
    padding-top --> 设置上内间距
    padding-buttom -->设置下内间距

    margin-right:设置右外间距
    margin-left --> 设置左外间距
    margin-top --> 设置上外间距
    margin-buttom -->设置下外间距

    padding和margin的复合写法:
        padding: 10px; 四个方向
        padding: 10px 15px;1.上下 2.左右
        padding:10px 15px 20px;1.上 2.左右 3.下
        padding:10px 15px 20px 25px;1.上 2.右 3.下 4.左
        
    margin --> 设置左右水平居中
        margin:X auto;
    相当于设置上下外边距为0,左右外边距为auto
    auto会自动计算容器的宽度,自身的宽度

    一般只有左右居中,没有上下居中
    如果要设置上下居中:
        1.给body设置行高
        2.把div设为行内块元素

        flex --> 弹性盒模型

## tips
    1.在布局时,为了保障后续的拓展性,大盒子一般不设置高度,让它随着内容自行拓展
    2.如果可以用父类实现排版,那就不要用子类来实现. 优先用父类排版

# 布局方式
	传统布局方式分为:
		1.文档流布局: 从上往下,从左往右,块元素独占一行 --> 默认(margin,padding,line-height)
		2.浮动布局 --> 让一个元素可以在父元素的内容区里向左/右进行浮动.直到碰到边界/其他浮动元素为止
		3.定位布局: 让一个元素在指定的位置显示:
			绝对定位 --> 基于父级的坐标进行移动
			相对定位 --> 基于元素本身进行移动
	目前比较主流的布局方式为flex(弹性盒模型布局)
		flex布局 --> 把网页根据两条轴 --> X轴/Y轴分割成多块. 再给里面的内容进行布局	

## 浮动篇(float)
	让我们可以更好的实现左右水平布局(之前的做法是把元素类型转为行内块元素.但这样有毛病:1.性能比较差 2.如果盒子内容超出了范围.排版会崩塌)

	基本上所有的标签都可以添加float样式.
	float只有两个属性:
		1.left 向左浮动
		2.right 向右浮动

	tips:
		1.元素在浮动式会从原有的布局范围脱离,在文档中不再占位
		2.父元素的内容区里向左/右进行浮动.直到碰到边界/其他浮动元素为止
		3.清除浮动 --> 如果父级元素没有设置高度.它会随着内容而撑大.但是如果给子元素设置了浮动.它就脱离了原来的位置.这种情况下父级不会被撑大了.所以为了解决这个,需要清除浮动
			最简单粗暴的办法就是给父级元素设置溢出处理: overflow:hidden;
			这样就可以解决高度崩塌
	
## 定位篇(position)
	通过定位来指定元素在网页出现的位置

	绝对定位(absolute): 让元素基于父级位置,在一个指定的坐标出现.让一个标签,出现在X多少,Y多少的位置
		- 绝对定位在移动后会脱离文档流.在文档中不再占位
		- 它的参考对象为离他的父元素进行移动.如果没有父元素,那就是按照网页大小进行移动
	相对定位(relative): 让元素基于自身位置,在原有基础上进行移动. 在原来位置上向X移动多少.向Y移动多少
		- 不会脱离文档流.相对移动之后不会影响其他元素的.只是自己的位置发生了改变
		- 不会改变元素的性质
		- 主要适合在小范围内移动

	定位的四个方向:
		top : ↑
		right : →
		bottom : ↓
		left : ←
	单纯写定位是没有没反应的.得结合定位的四个方向设置距离才有反应
	
	父相子绝:
		父元素为相对定位,子元素为绝对定位.子元素会按照定位后的父元素进行移动

	z-index:
		如果遇到元素产生上下堆叠时.可以使用z-index来调整位置. 值越大越靠上

## flex布局(弹性盒模型)
    flex是目前比较主流的布局方式 --> 它不举起来更加方便,取代float的作用 --> 浮动布局有缺陷,会脱离文档流.导致文档崩溃,移位

    用flex进行布局的元素,称为flex容器,它里面的子元素称为容器成员/flex项目 --> 项目

    flex布局 --> 原理就是通过两种轴,把网页分割成一个个的行和列,再进行对应的布局
        flex的主轴是从左往右 副轴(交叉轴)从上往下
    
    flex的使用:
        display:flex;
    
    设置主轴的方向: flex-direction
    row 行 column 列
        flex-direction: row;从左往右
        flex-direction: row-reverse;从右往左
        flex-direction: column;从上往下
        flex-direction: column-reverse;从下往上

    设置换行(如果主轴装不下内容): flex-wrap
        flex-wrap:no-wrap;默认不换行,让内容缩放,(按比例缩放塞满容器)
        flex-wrap:wrap;换行
    设置主轴的对齐方向:justify-content: space-between;
        flex-start;默认值,起点对齐,左/上
        flex-end;终点对齐,右/下
        space-between;两端对齐,
        左右对齐,让元素在左边和右边各自分摊
        space-around;所有的间距平均分配自动计算调整左右的间距
    设置副轴的对齐方式: align-items
        center;居中
        flex-start;
        flex-end;
## flex项目属性
    order : 项目的顺序,数值越小,排列越靠后
    flex-grow : 当主元素是复位时
    flex-shrink : 

## 伪元素
### 伪类选择器
    1.选择器拓展：
		伪类选择器：当满足特定条件时，触发对应的样式
            元素：hover{} 当鼠标经过元素时，触发功能
        伪元素选择器：创造一个虚假的元素，不能被选择，不存在DOM中(私密性/性能)
            元素::before{content:'内容'}
            元素::after{content:'内容'}
        结构选择器: 选择一个结构中的指定元素
            元素:nth-child(n){} --> 选中一个指定的子元素
            元素:first-child{} --> 选择第一个子元素
            元素:last-child{} --> 选择最后一个子元素
### 选择器补充
	之前学过的选择器:
		*: 通配符选择器.选中网页里的所有元素
		.类名: 类选择器.选中网页里的带有class='类名'的元素
		#id名: id选择器.选中网页里的带有id='类名'的元素
		标签名:标签选择器.选中网页里的所有该标签

		.msg img{}: 后代选择器.选中.msg 里面的所有img标签
		.msg > img{}: 子代选择器.只会选中msg里子元素的img标签.
		ul,li{}: 一次性选中多个内容

	伪类选择器 --> 相当于在指定的情况下,给标签添加了类名+样式
		元素:hover{} --> 当鼠标悬停/经过的时候触发样式	
		元素:link{} --> 当a标签未被访问时.触发的样式
		元素:visited{} --> 当a标签被访问过了.触发的样式
		元素:active{} --> 当按下元素时,触发样式
	对用户隐私不好 --> 你的领导坐你后面.懂前端 --> 网站会把你所有看过的网站都换色

	伪元素选择器 --> 伪元素就是创建了一个假的元素
		元素::before{content:'内容'} --> 在元素前面添加一个子元素内容
		元素::after{content:'内容'} --> 在元素后面添加一个子元素内容
	before:前  after:后
	content:内容.伪元素必须要有内容才能激活
	体现在性能以及安全性 --> 如果你希望你的页面里的一些内容(文本,图片)不能被选中.就可以用伪元素选择器来实现
		1.安全性.用伪元素写出来的东西并不是真正存在的,所以不能访问/选择它
		2.性能.因为它不能被选中,所以就少了一些交互请求,性能就会更好

	结构选择器:
		元素:nth-child(n) --> 选中元素的第n个子元素.(这个元素需要满足选择规则)
		元素:first-child --> 选中元素的第一个子元素
		元素:last-child --> 选择元素的最后一个子元素

		元素:nth-of-type(n) --> 选中元素里的第n个子元素.无视其他元素